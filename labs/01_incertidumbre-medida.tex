%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definir info del laboratorio
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\labheaderlogo}{img/logo-lab.png}
\renewcommand{\labfaculty}{Facultad de Ingeniería}
\renewcommand{\labschool}{Escuela Profesional de Ingeniería de Minas - Filial Haquira}

\renewcommand{\labnumber}{LABORATORIO N° 06 - Simulación}
\renewcommand{\labtitle}{Movimiento Armónico Simple (M.A.S.)}
\renewcommand{\labauthor}{Apellidos y Nombres}
\renewcommand{\labcourse}{\textbf{\textit{Curso:}} Física II - Unidad 3}
\renewcommand{\labcodigo}{\textbf{\textit{Código:}} 182739}
\renewcommand{\labinstitution}{Universidad Nacional Micaela Bastidas de Apurímac}
\renewcommand{\labdate}{12 de Noviembre del 2025}
\renewcommand{\labdocente}{\textbf{DOCENTE:} HUALLPA AIMITUMA Josué David}
\renewcommand{\lababstract}{
En este laboratorio virtual se estudia el Movimiento Armónico Simple (M.A.S.) mediante la implementación paso a paso de las ecuaciones del movimiento en una simulación construida con Manim. Los estudiantes analizarán la relación entre las condiciones iniciales, la frecuencia natural, la amplitud, el desfase y la posición de equilibrio. Además, implementarán el modelo matemático $x(t) = A\cos(\omega_0 t - \delta)$ y explorarán gráficamente cómo las variaciones en los parámetros físicos afectan el comportamiento del sistema masa-resorte. 
}

\renewcommand{\labemail}{autor@unamba.edu.pe}
\renewcommand{\labdoi}{10.1234/lab06}
\renewcommand{\labreceived}{12 Nov 2025}
\renewcommand{\labaccepted}{15 Nov 2025}
\renewcommand{\labpublished}{20 Nov 2025}
\renewcommand{\lablicense}{Licencia CC BY-NC-SA 4.0}

\labcover


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Inicio del Documento
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{OBJETIVOS}

\begin{enumerate}
    \item Comprender las ecuaciones que describen el movimiento armónico simple (M.A.S.) a partir de las leyes de Newton.
    \item Identificar la relación entre las condiciones iniciales y los parámetros característicos del sistema ($A$, $\omega_0$, $\delta$).
    \item Implementar una simulación en Manim que represente el movimiento oscilatorio de un bloque unido a un resorte.
    \item Analizar la correspondencia entre el modelo matemático y la animación obtenida.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{FUNDAMENTO TEÓRICO}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

El movimiento armónico simple (M.A.S.) describe el movimiento de una partícula o cuerpo que oscila alrededor de una posición de equilibrio bajo una fuerza restauradora proporcional al desplazamiento.

\subsection{Ecuación fundamental}
Partiendo de la segunda ley de Newton:

\begin{equation}
F = m a = -k x
\end{equation}

se obtiene la ecuación diferencial del movimiento:

\begin{equation}
m \frac{d^2 x}{dt^2} + k x = 0
\end{equation}

La solución general tiene la forma:
\begin{equation}
x(t) = A \cos(\omega_0 t - \delta)
\end{equation}

donde:
\begin{itemize}
    \item $A$: amplitud de oscilación (máximo desplazamiento)
    \item $\omega_0 = \sqrt{\frac{k}{m}}$: frecuencia angular natural
    \item $\delta$: desfase determinado por las condiciones iniciales
\end{itemize}

A partir de las condiciones iniciales $x(0) = x_0$ y $v(0) = v_0$, se tiene:
\begin{equation}
A = \sqrt{x_0^2 + \frac{v_0^2}{\omega_0^2}}, \qquad
\delta = \tan^{-1}\left(\frac{v_0}{\omega_0 x_0}\right)
\end{equation}

La energía mecánica del sistema se conserva:
\begin{equation}
E = \frac{1}{2}kA^2 = \frac{1}{2}k x^2 + \frac{1}{2} m v^2
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MATERIALES Y HERRAMIENTAS}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
    \item Entorno de programación \textbf{Python 3}.
    \item Librería \textbf{ManimCE} (Community Edition).
    \item Calculadora científica o simbólica (para derivar y comprobar ecuaciones).
    \item Bloc de notas para registro de resultados y observaciones.
\end{itemize}

\subsection*{Instalación y configuración de ManimCE}

Para la implementación de la simulación del Movimiento Armónico Simple (M.A.S.) es necesario instalar y configurar un entorno de trabajo compatible con \textbf{Manim Community Edition}. A continuación se detallan los pasos recomendados para usuarios de Windows (también aplicables a Linux o macOS con ligeras variaciones):

\subsubsection*{Instalación de Miniforge (gestor de entornos Python)}

Miniforge es una alternativa ligera a Anaconda y permite gestionar entornos aislados para proyectos científicos.  
Para descargarlo:

\begin{itemize}
    \item Buscar en la web: \texttt{``Download Miniforge GitHub''}.
    \item Seleccionar la versión: \texttt{Miniforge3-Windows-x86\_64.exe}.
    \item Instalar aceptando las opciones por defecto.
\end{itemize}

\subsubsection*{Creación del entorno virtual}

Abrir \textbf{Miniforge Prompt} y crear un entorno dedicado para ManimCE, considerar que ManimCE no siempre esta disponible para las versiones mas recientes de Python, a la fecha la versión mas reciente de Python es 3.14, pero esta es incompatible con la libreria actual de ManimCE, revisar la compatibilidad en la seción de instalación de la documentacion:

\begin{lstlisting}[style=modern-bash, numbers=none]
conda create -n manim-ce python=3.12
\end{lstlisting}

sigue las instruciones durante la creacion de el entorno virtual \textbf{manim-ce}, una vez finalizada activar el entorno con:
\begin{lstlisting}[style=modern-bash, numbers=none]
conda activate manim-ce
\end{lstlisting}



Es importante verificar que el nombre del entorno aparezca al inicio de la terminal, por ejemplo:

\begin{lstlisting}[style=modern-bash, numbers=none]
(manim-ce) C:\Users\usuario>
\end{lstlisting}

\subsubsection*{Instalación de ManimCE e IPython}

Una vez activado el entorno virtual \textbf{manim-ce}, instalar la libreria ManimCE desde la misma terminal usadno el repositorio de conda-forge:

\begin{lstlisting}[style=modern-bash, numbers=none]
conda install -c conda-forge manim
\end{lstlisting}

Para habilitar el modo interactivo con OpenGL (recomendado para pruebas rápidas), se obligatorio tener instalado IPython, la cual es una shell interactiva que permite la comunicacion entre el lienzo de OpenGL y Python de forma directa:

\begin{lstlisting}[style=modern-bash, numbers=none]
conda install -c conda-forge ipython
\end{lstlisting}

\subsubsection*{Instalación de Visual Studio Code (VSCode)}
Visual studio code es un editor de código que permitirá la programacion de la simulación de forma local desde el ordenador. Descargar VSCode desde:  
\url{https://code.visualstudio.com/}

En VSCode:

\begin{itemize}
    \item Abrir el panel de extensiones.
    \item Instalar la extensión \textbf{Python} (Microsoft).
    \item Abrir la paleta de comandos: \texttt{Ctrl + Shift + P}.
    \item Seleccionar: \texttt{Python: Select Interpreter}.
    \item Elegir el intérprete correspondiente al entorno \texttt{manim-ce}.
\end{itemize}

\subsubsection*{Organización del proyecto}

Para comenzar, es fundamental establecer una estructura de carpetas clara. Se recomienda crear el directorio de trabajo principal en el Escritorio (\texttt{Desktop}) o Documentos (\texttt{Documents}).Siga los pasos a continuación en la terminal de Miniforge Prompt para configurar la estructura de directorios:

\begin{enumerate}
    \item \textbf{Verificar ubicación}: Utilice el comando \texttt{dir} para listar los archivos y carpetas del directorio actual.
    \item \textbf{Navegar al Escritorio}: Ingrese al directorio del Escritorio. Deberá verificar el nombre correcto de la carpeta (generalmente \texttt{Desktop} o \texttt{Escritorio}) ejecutando previamente \texttt{dir}.
    \item \textbf{Crear la Carpeta Principal}: Una vez ubicado en el Escritorio, cree la carpeta para el proyecto de Física II.
    \item \textbf{Acceder a la Carpeta Principal}: Ingrese al directorio de \texttt{Fisica-II}.
    \item \textbf{Crear el Subdirectorio de Manim}: Dentro de la carpeta \texttt{Fisica-II}, cree el subdirectorio para los archivos de Manim.
    \item \textbf{Acceder al Directorio de Trabajo}: Ingrese al directorio \texttt{manim}.
\end{enumerate}
\begin{lstlisting}[style=modern-bash]
dir 
cd Desktop
mkdir Fisica-II
cd Fisica-II
mkdir manim
cd manim
\end{lstlisting}

Luego abrir dicha carpeta con VSCode:

\begin{lstlisting}[style=modern-bash,  numbers=none]
code .
\end{lstlisting}

Crear un archivo llamado:

\begin{lstlisting}[style=modern-bash,  numbers=none]
mas.py
\end{lstlisting}

y colocarlo dentro de la carpeta \texttt{manim}.


\subsubsection*{Prueba de funcionamiento}

Para verificar que ManimCE con soporte OpenGL está instalado correctamente, crear un archivo llamado \texttt{mas.py} con el siguiente contenido:

\begin{lstlisting}[style=modern-python]
from manim import *
from manim.opengl import *

class ManimOpenGL(Scene):
    def construct(self):
        # Crear un texto usando ManimCE
        t = Text("Hola desde ManimCE")

        # Animar el texto con Write
        self.play(Write(t))

        # Entrar al modo interactivo (requiere OpenGL)
        self.interactive_embed()
\end{lstlisting}

Este script contiene la estructura mínima para un proyecto con OpenGL:

\begin{itemize}
    \item \texttt{from manim import *} importa las herramientas principales de ManimCE.
    \item \texttt{from manim.opengl import *} habilita el renderizado y objetos basados en OpenGL.
    \item La clase \texttt{ManimOpenGL(Scene)} define una escena que será procesada por Manim.
    \item El método \texttt{construct()} es el punto donde se construyen las animaciones.
    \item \verb|self.play(Write(t))| muestra el texto mediante la animación de escritura.
    \item\verb|self.interactive_embed()| activa el modo interactivo en IPython, disponible solo si OpenGL funciona correctamente.
\end{itemize}

Luego ejecutar en la terminal:

\begin{lstlisting}[style=modern-bash,  numbers=none]
manim -qm -p --renderer=opengl mas.py ManimOpenGL
\end{lstlisting}

Si durante la ejecución aparece una ventana de OpenGL con la animación
``Hola desde ManimCE'', y después se abre automáticamente un intérprete IPython en la terminal (Miniforge Prompt), entonces la instalación de ManimCE con soporte OpenGL se ha completado correctamente.

A veces es necesario decidir si se desea renderizar la animación como un
video o simplemente visualizarla en una ventana mediante OpenGL. La elección
depende del propósito:

\begin{itemize}
    \item \textbf{Ventana OpenGL (previsualización interactiva)}:  
    Es útil durante el desarrollo de una escena, cuando se desea observar
    rápidamente el comportamiento de los objetos, las transformaciones o la
    sincronización de las animaciones.  
    Este modo no genera archivos de video; simplemente abre una ventana con
    la animación, permitiendo iterar y depurar más rápido.

    \item \textbf{Renderizado como video (resultado final)}:  
    Se usa cuando la escena ya está terminada y se necesita producir un video
    reproducible, estable y con una calidad determinada (\texttt{-ql},
    \texttt{-qm}, \texttt{-qh}).  
    Este archivo puede luego incluirse en informes, presentaciones o material
    de clase. El render en video garantiza consistencia visual y mejor
    iluminación que la previsualización OpenGL.
\end{itemize}

Para generar un video en calidad media y abrirlo automáticamente,  solo es necesario omitir OpenGL:

\begin{lstlisting}[style=modern-bash, numbers=none]
manim -qm -p mas.py ManimOpenGL
\end{lstlisting}

\subsubsection*{Recomendaciones adicionales}

\begin{itemize}
    \item Mantener el entorno \texttt{manim-ce} exclusivamente para proyectos gráficos.
    \item Evitar mezclar versiones de Python fuera del entorno virtual.
    \item Utilizar el comando: \texttt{conda info --envs} para verificar los entornos instalados.
    \item En caso de errores gráficos en Windows, instalar o actualizar drivers OpenGL/DirectX.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{PROCEDIMIENTO EXPERIMENTAL}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

En esta sección se explica detalladamente cómo implementar, probar y depurar
la simulación del Movimiento Armónico Simple (M.A.S.) usando \textbf{ManimCE}
con \textbf{OpenGL} y una shell interactiva (\texttt{IPython}). El objetivo es
que el estudiante pueda testear pequeñas porciones de código desde la sesión
interactiva y, una vez verificado su comportamiento, integrarlas en el archivo
final \texttt{mas.py}.

\subsection*{Flujo de trabajo recomendado}
\begin{enumerate}
    \item Abrir \textbf{Miniforge Prompt} y activar el entorno \texttt{manim-ce}:
    \begin{lstlisting}[style=modern-bash, numbers=none]
        conda activate manim-ce
    \end{lstlisting}

    \item Abrir un editor (VSCode) en la carpeta del proyecto y crear \texttt{mas.py}.
    \item Ejecutar la escena en modo OpenGL con IPython para permitir inspección
    y modificación en caliente:
    \begin{lstlisting}[style=modern-bash, numbers=none]
        manim -qm -p --renderer=opengl mas.py MAS
    \end{lstlisting}
    Cuando la escena alcanza \texttt{self.interactive\_embed()} se abrirá un
    intérprete \texttt{IPython} conectado a la escena (variable \texttt{scene}
    disponible). Desde allí se pueden ejecutar comandos para crear, modificar y
    eliminar \textit{mobjects} sin recompilar todo el archivo.
\end{enumerate}

\subsection*{Estructura general del código (explicación por secciones)}

A continuación se detalla cada bloque de la clase \texttt{MAS} y se explica
cómo probarlo interactivamente. El código que seguiremos es el siguiente:

\begin{lstlisting}[style=modern-python, caption={Clase completa (referencia)}]
class MAS(Scene):
    def construct(self):
        # ... (todo el código que se presenta más abajo por secciones)
        self.interactive_embed()
\end{lstlisting}

Trabajaremos sección por sección: variables, condiciones iniciales,
interfaz (texto y fórmulas), ejes/plot, masa–resorte (geometría) y animadores (updaters).

\subsubsection*{1. Variables globales y temporizador}
Definición y propósito:

\begin{lstlisting}[style=modern-python]
# VARIABLES GLOBALES
tiempo_interno = ValueTracker(0)   # variable que la escena animará; leer con .get_value()
ESCALA = 0.5                       # escala visual entre unidades físicas y la pantalla
tiempo_simulado = 18               # duración total de la simulación (s)
\end{lstlisting}

\textbf{Probar en IPython:}
\begin{itemize}
    \item En IPython escribir: \verb|tiempo_interno.get_value()| para ver el valor.
    \item Para avanzar manualmente durante pruebas: \verb|tiempo_interno.set_value(2.5)|.
\end{itemize}

\subsubsection*{2. Parámetros físicos y función $x(t)$}
Definición, significado y pruebas:

\begin{lstlisting}[style=modern-python]
# Condiciones iniciales y parámetros físicos
x0 = 1.5
v0 = 3
k = 10
m = 3
g = 9.81

# parámetros calculados
w0 = np.sqrt(k / m)
A = np.sqrt(x0**2 + (v0**2) / (w0**2))
delta = np.arctan2(v0, w0 * x0)
x_equilibrio = (m * g) / k

# función x(t)
def x(t):
    return A * np.cos(w0 * t - delta)
\end{lstlisting}

\textbf{Probar en IPython:}
\begin{itemize}
    \item Evaluar valores numéricos: \verb|A, w0, delta, x_equilibrio|.
    \item Evaluar la función en un tiempo: \verb|x(0), x(0.5), x(3.14)|.
    \item Si las expresiones dan \texttt{nan} o \texttt{inf}, revisar entradas (ej. $x_0$=0).
\end{itemize}

\subsubsection*{3. Interfaz: Título y ecuaciones en pantalla}
Cómo crear y probar textos/MathTex:

\begin{lstlisting}[style=modern-python]
# Título
Titulo = Text("LAB 06: M.A.S.", font_size=24)
Titulo.move_to(UP * 3)
self.play(Write(Titulo))

# Ecuaciones
x_tex = MathTex(r"x(t)=A\cos(\omega_0 t - \delta)", font_size=24)
x_tex.to_corner(UL)
A_tex = MathTex(r"A=\sqrt{x_0^2+\frac{\dot{x}_0^2}{\omega_0^2}}", font_size=24)
A_tex.next_to(x_tex, DOWN)
delta_tex = MathTex(r"\delta = \tan^{-1}\!\left(\frac{\dot{x}_0}{\omega_0 x_0}\right)", font_size=24)
delta_tex.next_to(A_tex, DOWN)
omega_tex = MathTex(r"\omega_0 = \sqrt{\frac{k}{m}}", font_size=24)
omega_tex.next_to(delta_tex, DOWN)

self.play(Write(x_tex), Write(A_tex), Write(delta_tex), Write(omega_tex))
\end{lstlisting}

\textbf{Probar en IPython:}
\begin{itemize}
    \item Una vez en el intérprete interactivo, crear una instancia de \texttt{Text} o \texttt{MathTex} y añadirla: \\
    \verb|Titulo = Text("Prueba"); scene.add(Titulo); scene.renderer.force_redraw(scene)|
    \item Para borrar: \verb|scene.remove(Titulo); scene.renderer.force_redraw(scene)|.
\end{itemize}

\subsubsection*{4. Ejes y gráfica de $x(t)$}
Crear ejes y comprobar rangos:

\begin{lstlisting}[style=modern-python]
ejes = Axes(
    x_range=[0, tiempo_simulado, 1],
    y_range=[-A, A, 1],
    x_length=tiempo_simulado * ESCALA,
    y_length=2 * A * ESCALA,
    axis_config={
        "include_tip": False,
        "include_ticks": True,
        "include_numbers": True,
        "font_size": 24,
    }
)
ejes.to_corner(DL)
self.play(Create(ejes))
\end{lstlisting}

\textbf{Probar en IPython:}
\begin{itemize}
    \item \verb|ejes.c2p(1, 0)| convierte coordenadas (t, x) a coordenadas de pantalla;
    \item comprobar que \verb|ejes.c2p(0,0)| coincide con la línea de equilibrio visual.
\end{itemize}

\subsubsection*{5. Construcción del sistema masa--resorte}
El siguiente código construye el sistme masa resorte de la simulacion

\begin{lstlisting}[style=modern-python]
# techo
techo = Dot(color=GREY)
self.add(techo)

# linea de equilibrio
linea_equilibrio = DashedLine(start=[-0.5,0,0], end=[0.5,0,0])
linea_equilibrio.shift(DOWN * x_equilibrio)

# bloque de masa
bloque_masa = Square(0.5, color=BLUE)
bloque_masa.set_fill(BLUE, opacity=0.7)
bloque_masa.move_to(linea_equilibrio.get_center())

# centro de masa
cm = Dot(color=RED)
cm.move_to(bloque_masa.get_center())

# resorte
resorte = Line(color=YELLOW, start=techo.get_center(), end=cm.get_center())

# etiquetas y líneas auxiliares (+A, -A, x0)
etiqueta_equilibrio = MathTex(r"x=0", font_size=20)
etiqueta_equilibrio.next_to(linea_equilibrio, RIGHT)
linea_A_mas = DashedLine(start=[-0.5,0,0], end=[0.5,0,0])
linea_A_mas.shift(linea_equilibrio.get_center() + A * ESCALA * UP)
linea_A_menos = DashedLine(start=[-0.5,0,0], end=[0.5,0,0])
linea_A_menos.shift(linea_equilibrio.get_center() - A * ESCALA * UP)
etiqueta_A_mas = MathTex(f"A={A:.2f}", font_size=20)
etiqueta_A_mas.next_to(linea_A_mas, RIGHT)
etiqueta_A_menos = MathTex(f"A={-A:.2f}", font_size=20)
etiqueta_A_menos.next_to(linea_A_menos, RIGHT)
linea_x0 = DashedLine(start=[-0.5,0,0], end=[0.5,0,0])
linea_x0.shift(linea_equilibrio.get_center() + x0 * ESCALA * UP)

sistema_masa_resorte = VGroup(
    techo, linea_equilibrio, bloque_masa, cm, resorte,
    etiqueta_equilibrio, linea_A_mas, linea_A_menos,
    etiqueta_A_mas, etiqueta_A_menos, linea_x0
)
sistema_masa_resorte.next_to(ejes, RIGHT, buff=1)
\end{lstlisting}

\textbf{Probar en IPython:}
\begin{itemize}
    \item Crear cada objeto por separado y añadirlo: \verb|scene.add(bloque_masa)|.  
    \item Mover el bloque con \verb|bloque_masa.move_to([x,y,0])| y forzar redraw:
    \verb|scene.renderer.force_redraw(scene)|.
\end{itemize}

\subsubsection*{6. Updaters y animación (vincular $x(t)$ al objeto)}
Explicación de updaters y su uso con \texttt{ValueTracker}:

\begin{lstlisting}[style=modern-python]
# updaters que hacen que los objetos sigan la física
bloque_masa.add_updater(
    lambda m: m.move_to(linea_equilibrio.get_center() + ESCALA * x(tiempo_interno.get_value()) * UP)
)
cm.add_updater(lambda m: m.move_to(bloque_masa.get_center()))
resorte.add_updater(lambda m: m.put_start_and_end_on(techo.get_center(), cm.get_center()))

# punto en la grafica y su traza
punto_grafica = always_redraw(lambda: Dot(
    ejes.c2p(tiempo_interno.get_value(), x(tiempo_interno.get_value())),
    color=RED, radius=0.05
))
trayectoria = TracedPath(punto_grafica.get_center, stroke_color=RED, stroke_width=2)
self.add(punto_grafica, trayectoria)

# ejecutar la animación temporal
self.play(
    tiempo_interno.animate.set_value(tiempo_simulado),
    run_time=tiempo_simulado,
    rate_func=linear
)
\end{lstlisting}

\textbf{Qué prueba cada línea:}
\begin{itemize}
    \item \texttt{add\_updater(lambda m: ...)}: cada frame la lambda se ejecuta y mueve el mobject.
    \item \texttt{always\_redraw(...) } crea un mobject que se recomputa cada frame (útil para puntos).
    \item \texttt{tiempo\_interno.animate.set\_value(...)} anima el ValueTracker y activa los updaters.
\end{itemize}

\subsection*{Probar interactivamente: ejemplos de comandos útiles en IPython}

Mientras la escena está detenida en \texttt{self.interactive\_embed()} la variable \texttt{scene}
está disponible. Algunos comandos útiles:

\begin{lstlisting}[style=modern-python]
# Añadir objetos rápidamente
scene.add(Text("Prueba Rápida").move_to(LEFT))

# Eliminar un objeto (suponiendo que su variable es t)
scene.remove(t)
scene.renderer.force_redraw(scene)

# Cambiar el valor del time tracker para ver efecto inmediato
tiempo_interno.set_value(2.5)
scene.renderer.force_redraw(scene)

# Borrar updaters (útil si el objeto queda "pegado")
bloque_masa.clear_updaters()
scene.renderer.force_redraw(scene)
\end{lstlisting}

\subsubsection*{Cómo limpiar OpenGL y el estado entre pruebas}
A veces, después de múltiples pruebas interactivas, el estado gráfico queda
en memoria o la ventana OpenGL queda abierta. Recomendaciones ordenadas:

\begin{enumerate}
    \item \textbf{Cerrar la ventana OpenGL}: normalmente cerrando la ventana con el ratón o teclado (tecla de cierre) es suficiente, de no ser asi, desde la terminal de IPython ejecutar \texttt{exit}.
    \item \textbf{Detener el proceso}: si la ejecución quedó colgada, en la terminal presionar \texttt{Ctrl+C} para forzar la interrupción.
    \item \textbf{Limpiar variables en IPython}: en el prompt interactivo ejecutar:
    \begin{lstlisting}[style=modern-bash, numbers=none]
%reset -f
    \end{lstlisting}
    Esto borra todas las variables definidas durante la sesión.
    \item \textbf{Reiniciar el kernel/IPython}: si persisten problemas, cerrar el intérprete y volver a lanzar el comando \texttt{manim ...} desde la terminal.
    \item \textbf{Eliminar updaters y forzar redraw} (si trabajas dentro del intérprete y no quieres reiniciar):
    \begin{lstlisting}[style=modern-python]
bloque_masa.clear_updaters()
scene.remove_all_mobjects()  # si el helper está disponible
scene.renderer.force_redraw(scene)
    \end{lstlisting}
    Nota: \verb|scene.remove_all_mobjects()| no es API oficial en todas las versiones; si no existe, remover explícitamente los mobjects que conozcas con \texttt{scene.remove(obj)}.
\end{enumerate}

\subsection*{Migrar código probado al archivo \texttt{mas.py}}
\begin{enumerate}
    \item Una vez que una porción de código (por ejemplo: definición de ejes,
    o el updater del bloque) funciona en IPython, copiar ese bloque en
    \texttt{mas.py} dentro del método \texttt{construct()} en el orden correcto:
    \begin{enumerate}
        \item definir variables y funciones matemáticas,
        \item crear interfaz (Text, MathTex),
        \item construir ejes,
        \item crear elementos del sistema masa--resorte,
        \item adjuntar updaters,
        \item ejecutar la animación con \texttt{self.play(...)}.
    \end{enumerate}
    \item Guardar \texttt{mas.py} y ejecutar fuera del intérprete para generar
    el video final:
    \begin{lstlisting}[style=modern-bash, numbers=none]
manim -qm -p mas.py MAS
    \end{lstlisting}
\end{enumerate}

\subsection*{Qué hacer si aparece un error}
Si a pesar de las instrucciones aparece un error, copia todo el \textbf{traceback}
(de la terminal) y pégalo en ChatGPT junto al fragmento de código que estabas
probando. Para obtener ayuda rápida, se sugiere a los estudiantes usar el siguiente
prompt (copiar/pegar):

\begin{lstlisting}[style=modern-bash]
# Prompt sugerido para ChatGPT/ayuda:
"Estoy probando una escena en ManimCE con OpenGL. 
Adjunto el traceback completo (incluye las últimas 20-50 líneas) y el 
fragmento de código que causa el error. 
Por favor, indícame: 1) posible causa, 2) 2-3 soluciones prácticas, 
3) si necesitas más información, qué exactamente debo pegar."
\end{lstlisting}

\textbf{Consejos al pegar errores:}
\begin{itemize}
    \item Incluye las primeras y últimas 30-50 líneas del traceback (no solo la última línea).
    \item Indica la versión de Python (\texttt{python --version}) y la versión de Manim (\texttt{manim --version}).
    \item Si el error ocurre al renderizar con OpenGL, pega también el comando exacto que ejecutaste.
\end{itemize}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Preguntas de Análisis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{enumerate}
    \item ¿Qué ocurre con la frecuencia natural si la masa del bloque se duplica?
    \item ¿Qué significa físicamente el desfase $\delta$?
    \item Compare la amplitud teórica con la amplitud visual observada.
    \item ¿Cómo se comportaría el sistema si se introdujera rozamiento?
    \item Si $k = 10$ N/m y $m = 2$ kg, calcule el período de oscilación.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{CONCLUSIONES}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
    \item El modelo matemático del M.A.S. describe con precisión la trayectoria oscilatoria de un sistema masa-resorte.
    \item La simulación en Manim permite visualizar la relación entre los parámetros físicos y la forma del movimiento.
    \item La frecuencia natural depende únicamente de la masa y la constante elástica, mientras que la amplitud depende de las condiciones iniciales.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{REFERENCIAS}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{enumerate}
    \item Serway, R. \& Jewett, J. (2019). \textit{Física para ciencias e ingeniería}, Vol. I. Cengage Learning.
    \item Young, H. \& Freedman, R. (2020). \textit{Física Universitaria}, Pearson, 14a Edición.
    \item Manim Community. (2025). \textit{Documentación oficial de ManimCE}. Disponible en: \url{https://docs.manim.community/}


        \begin{equation*}
            x(t)=A\cos{\omega_0 t- \delta}
        \end{equation*}

        \begin{equation*}
            x(2.2)=A\cos{\omega_0 2.2- \delta}
        \end{equation*}
\end{enumerate}

